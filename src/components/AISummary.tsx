
import React, { useEffect, useState } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { AlertTriangle, Check } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Skeleton } from "@/components/ui/skeleton";

interface AISummaryProps {
  issues: any[];
  address: string;
}

const AISummary: React.FC<AISummaryProps> = ({ issues, address }) => {
  const [summary, setSummary] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const generateSummary = async () => {
      if (!issues || issues.length === 0) {
        setSummary('No issues found for this building.');
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        // Prepare data for the AI
        const issueCategories = countIssuesByCategory(issues);
        const recentIssues = issues
          .slice(0, 10)
          .map(issue => ({
            category: issue["Major Category"] || "Unknown",
            subcategory: issue["Minor Category"] || "Unknown",
            status: issue["Complaint Status"] || "Unknown",
            description: issue["Status Description"] || "No description"
          }));

        // Call our edge function to generate the summary
        const { data, error } = await supabase.functions.invoke('generate-summary', {
          body: {
            address,
            issueCategories,
            recentIssues,
            totalIssues: issues.length
          }
        });

        if (error) throw error;

        setSummary(data.summary);
      } catch (err) {
        console.error("Error generating AI summary:", err);
        setError('Failed to generate building summary. Please try again later.');
      } finally {
        setLoading(false);
      }
    };

    generateSummary();
  }, [issues, address]);

  // Helper function to count issues by category
  const countIssuesByCategory = (issues: any[]) => {
    return issues.reduce((acc, issue) => {
      const category = issue["Major Category"] || "Unknown";
      if (!acc[category]) acc[category] = 0;
      acc[category]++;
      return acc;
    }, {} as Record<string, number>);
  };

  if (loading) {
    return (
      <div className="space-y-4">
        <div className="flex items-center space-x-4 mb-4">
          <div className="space-y-2">
            <Skeleton className="h-4 w-[250px]" />
            <Skeleton className="h-4 w-[200px]" />
          </div>
        </div>
        <Skeleton className="h-[200px] w-full rounded-xl" />
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertTriangle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>{error}</AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-4">
      <div className="bg-blue-50 border border-blue-100 rounded-lg p-4">
        <h3 className="text-sm font-medium flex items-center gap-2 text-blue-700 mb-2">
          <Check className="h-4 w-4" />
          AI-Generated Building Summary
        </h3>
        <div className="prose prose-sm max-w-none">
          {summary.split('\n').map((paragraph, i) => (
            <p key={i} className={i === 0 ? "font-medium" : ""}>
              {paragraph}
            </p>
          ))}
        </div>
        <p className="text-xs text-gray-500 mt-4 italic">
          This summary was generated by AI based on {issues.length} reported issues. The information should be verified independently.
        </p>
      </div>
    </div>
  );
};

export default AISummary;
